//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

extension Rocket.Content {

    /** Returns the details of a Plan with the specified id. */
    public enum GetPlan {

        public static let service = APIService<Response>(id: "getPlan", tag: "content", method: "GET", path: "/plans/{id}", hasBody: false, securityRequirements: [])

        public final class Request: APIRequest<Response> {

            public struct Options {

                /** The identifier of the Plan to load. */
                public var id: String

                /** The type of device the content is targeting. */
                public var device: String?

                /** The active subscription code. */
                public var sub: String?

                /** The list of segments to filter the response by. */
                public var segments: [String]?

                /** The set of opt in feature flags which cause breaking changes to responses.
While Rocket APIs look to avoid breaking changes under the active major version, the formats of responses
may need to evolve over this time.
These feature flags allow clients to select which response formats they expect and avoid breaking
clients as these formats evolve under the current major version.
### Flags
- `all` - Enable all flags. Useful for testing. _Don't use in production_.
- `idp` - Dynamic item detail pages with schedulable rows.
- `ldp` - Dynamic list detail pages with schedulable rows.
See the `feature-flags.md` for available flag details.
 */
                public var ff: [FeatureFlags]?

                public init(id: String, device: String? = nil, sub: String? = nil, segments: [String]? = nil, ff: [FeatureFlags]? = nil) {
                    self.id = id
                    self.device = device
                    self.sub = sub
                    self.segments = segments
                    self.ff = ff
                }
            }

            public var options: Options

            public init(options: Options) {
                self.options = options
                super.init(service: GetPlan.service)
            }

            /// convenience initialiser so an Option doesn't have to be created
            public convenience init(id: String, device: String? = nil, sub: String? = nil, segments: [String]? = nil, ff: [FeatureFlags]? = nil) {
                let options = Options(id: id, device: device, sub: sub, segments: segments, ff: ff)
                self.init(options: options)
            }

            public override var path: String {
                return super.path.replacingOccurrences(of: "{" + "id" + "}", with: "\(self.options.id)")
            }

            public override var queryParameters: [String: Any] {
                var params: [String: Any] = [:]
                if let device = options.device {
                  params["device"] = device
                }
                if let sub = options.sub {
                  params["sub"] = sub
                }
                if let segments = options.segments?.joined(separator: ",") {
                  params["segments"] = segments
                }
                if let ff = options.ff?.encode().map({ String(describing: $0) }).joined(separator: ",") {
                  params["ff"] = ff
                }
                return params
            }
        }

        public enum Response: APIResponseValue, CustomStringConvertible, CustomDebugStringConvertible {

            /** Returns the details of a Plan with the specified id. */
            public class Status200: APIModel {

                /** The type of plan. */
                public enum `Type`: String, Codable, Equatable, CaseIterable {
                    case free = "Free"
                    case subscription = "Subscription"
                }

                /** The revenue type a plan targets. */
                public enum RevenueType: String, Codable, Equatable, CaseIterable {
                    case tvod = "TVOD"
                    case svod = "SVOD"
                }

                /** The type of billing period used. */
                public enum BillingPeriodType: String, Codable, Equatable, CaseIterable {
                    case week = "week"
                    case month = "month"
                    case year = "year"
                    case none = "none"
                }

                /** The identifier of a plan. */
                public var id: String

                /** The title of a plan. */
                public var title: String

                /** The short tagline for a plan. */
                public var tagline: String

                /** The type of plan. */
                public var type: `Type`

                /** True if a plan should be highlighted as featured, false if not. */
                public var isFeatured: Bool

                /** True if a plan is active, false if its retired. */
                public var isActive: Bool

                /** True if a plan should not be presented in the primary plan options, false if not. */
                public var isPrivate: Bool

                /** The revenue type a plan targets. */
                public var revenueType: RevenueType

                /** The subscription code a plan targets. */
                public var subscriptionCode: String

                /** An alias for a plan. */
                public var alias: String

                /** The list of benefits to display for a plan. */
                public var benefits: [String]

                /** The type of billing period used. */
                public var billingPeriodType: BillingPeriodType

                /** Given the `billingPeriodType` this is how frequently it will run. e.g. every 2 weeks. */
                public var billingPeriodFrequency: Int

                /** True if a plan has a trial period, false if not. */
                public var hasTrialPeriod: Bool

                /** How many days a trial period runs for a plan. Only valid if `hasTrialPeriod` is true. */
                public var trialPeriodDays: Int

                /** The terms and conditions for a plan. */
                public var termsAndConditions: String

                /** The currency a plan is offered in. */
                public var currency: String

                /** A map of custom fields defined by a curator for a plan. */
                public var customFields: [String: Any]?

                /** The price of a plan. If a free plan then undefined. */
                public var price: Float?

                public init(id: String, title: String, tagline: String, type: `Type`, isFeatured: Bool, isActive: Bool, isPrivate: Bool, revenueType: RevenueType, subscriptionCode: String, alias: String, benefits: [String], billingPeriodType: BillingPeriodType, billingPeriodFrequency: Int, hasTrialPeriod: Bool, trialPeriodDays: Int, termsAndConditions: String, currency: String, customFields: [String: Any]? = nil, price: Float? = nil) {
                    self.id = id
                    self.title = title
                    self.tagline = tagline
                    self.type = type
                    self.isFeatured = isFeatured
                    self.isActive = isActive
                    self.isPrivate = isPrivate
                    self.revenueType = revenueType
                    self.subscriptionCode = subscriptionCode
                    self.alias = alias
                    self.benefits = benefits
                    self.billingPeriodType = billingPeriodType
                    self.billingPeriodFrequency = billingPeriodFrequency
                    self.hasTrialPeriod = hasTrialPeriod
                    self.trialPeriodDays = trialPeriodDays
                    self.termsAndConditions = termsAndConditions
                    self.currency = currency
                    self.customFields = customFields
                    self.price = price
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    id = try container.decode("id")
                    title = try container.decode("title")
                    tagline = try container.decode("tagline")
                    type = try container.decode("type")
                    isFeatured = try container.decode("isFeatured")
                    isActive = try container.decode("isActive")
                    isPrivate = try container.decode("isPrivate")
                    revenueType = try container.decode("revenueType")
                    subscriptionCode = try container.decode("subscriptionCode")
                    alias = try container.decode("alias")
                    benefits = try container.decodeArray("benefits")
                    billingPeriodType = try container.decode("billingPeriodType")
                    billingPeriodFrequency = try container.decode("billingPeriodFrequency")
                    hasTrialPeriod = try container.decode("hasTrialPeriod")
                    trialPeriodDays = try container.decode("trialPeriodDays")
                    termsAndConditions = try container.decode("termsAndConditions")
                    currency = try container.decode("currency")
                    customFields = try container.decodeAnyIfPresent("customFields")
                    price = try container.decodeIfPresent("price")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encode(id, forKey: "id")
                    try container.encode(title, forKey: "title")
                    try container.encode(tagline, forKey: "tagline")
                    try container.encode(type, forKey: "type")
                    try container.encode(isFeatured, forKey: "isFeatured")
                    try container.encode(isActive, forKey: "isActive")
                    try container.encode(isPrivate, forKey: "isPrivate")
                    try container.encode(revenueType, forKey: "revenueType")
                    try container.encode(subscriptionCode, forKey: "subscriptionCode")
                    try container.encode(alias, forKey: "alias")
                    try container.encode(benefits, forKey: "benefits")
                    try container.encode(billingPeriodType, forKey: "billingPeriodType")
                    try container.encode(billingPeriodFrequency, forKey: "billingPeriodFrequency")
                    try container.encode(hasTrialPeriod, forKey: "hasTrialPeriod")
                    try container.encode(trialPeriodDays, forKey: "trialPeriodDays")
                    try container.encode(termsAndConditions, forKey: "termsAndConditions")
                    try container.encode(currency, forKey: "currency")
                    try container.encodeAnyIfPresent(customFields, forKey: "customFields")
                    try container.encodeIfPresent(price, forKey: "price")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status200 else { return false }
                  guard self.id == object.id else { return false }
                  guard self.title == object.title else { return false }
                  guard self.tagline == object.tagline else { return false }
                  guard self.type == object.type else { return false }
                  guard self.isFeatured == object.isFeatured else { return false }
                  guard self.isActive == object.isActive else { return false }
                  guard self.isPrivate == object.isPrivate else { return false }
                  guard self.revenueType == object.revenueType else { return false }
                  guard self.subscriptionCode == object.subscriptionCode else { return false }
                  guard self.alias == object.alias else { return false }
                  guard self.benefits == object.benefits else { return false }
                  guard self.billingPeriodType == object.billingPeriodType else { return false }
                  guard self.billingPeriodFrequency == object.billingPeriodFrequency else { return false }
                  guard self.hasTrialPeriod == object.hasTrialPeriod else { return false }
                  guard self.trialPeriodDays == object.trialPeriodDays else { return false }
                  guard self.termsAndConditions == object.termsAndConditions else { return false }
                  guard self.currency == object.currency else { return false }
                  guard NSDictionary(dictionary: self.customFields ?? [:]).isEqual(to: object.customFields ?? [:]) else { return false }
                  guard self.price == object.price else { return false }
                  return true
                }

                public static func == (lhs: Status200, rhs: Status200) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            /** Returns the details of a Plan with the specified id. */
            public class Status400: APIModel {

                /** A description of the error. */
                public var message: String

                /** An optional code classifying the error. Should be taken in the context of the http status code. */
                public var code: Int?

                public init(message: String, code: Int? = nil) {
                    self.message = message
                    self.code = code
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    message = try container.decode("message")
                    code = try container.decodeIfPresent("code")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encode(message, forKey: "message")
                    try container.encodeIfPresent(code, forKey: "code")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status400 else { return false }
                  guard self.message == object.message else { return false }
                  guard self.code == object.code else { return false }
                  return true
                }

                public static func == (lhs: Status400, rhs: Status400) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            /** Returns the details of a Plan with the specified id. */
            public class Status404: APIModel {

                /** A description of the error. */
                public var message: String

                /** An optional code classifying the error. Should be taken in the context of the http status code. */
                public var code: Int?

                public init(message: String, code: Int? = nil) {
                    self.message = message
                    self.code = code
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    message = try container.decode("message")
                    code = try container.decodeIfPresent("code")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encode(message, forKey: "message")
                    try container.encodeIfPresent(code, forKey: "code")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status404 else { return false }
                  guard self.message == object.message else { return false }
                  guard self.code == object.code else { return false }
                  return true
                }

                public static func == (lhs: Status404, rhs: Status404) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            /** Returns the details of a Plan with the specified id. */
            public class Status500: APIModel {

                /** A description of the error. */
                public var message: String

                /** An optional code classifying the error. Should be taken in the context of the http status code. */
                public var code: Int?

                public init(message: String, code: Int? = nil) {
                    self.message = message
                    self.code = code
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    message = try container.decode("message")
                    code = try container.decodeIfPresent("code")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encode(message, forKey: "message")
                    try container.encodeIfPresent(code, forKey: "code")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status500 else { return false }
                  guard self.message == object.message else { return false }
                  guard self.code == object.code else { return false }
                  return true
                }

                public static func == (lhs: Status500, rhs: Status500) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            /** Returns the details of a Plan with the specified id. */
            public class DefaultResponse: APIModel {

                /** A description of the error. */
                public var message: String

                /** An optional code classifying the error. Should be taken in the context of the http status code. */
                public var code: Int?

                public init(message: String, code: Int? = nil) {
                    self.message = message
                    self.code = code
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    message = try container.decode("message")
                    code = try container.decodeIfPresent("code")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encode(message, forKey: "message")
                    try container.encodeIfPresent(code, forKey: "code")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? DefaultResponse else { return false }
                  guard self.message == object.message else { return false }
                  guard self.code == object.code else { return false }
                  return true
                }

                public static func == (lhs: DefaultResponse, rhs: DefaultResponse) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }
            public typealias SuccessType = Status200

            /** The Plan requested. */
            case status200(Status200)

            /** Bad request. */
            case status400(Status400)

            /** Not found. */
            case status404(Status404)

            /** Internal server error. */
            case status500(Status500)

            /** Service error. */
            case defaultResponse(statusCode: Int, DefaultResponse)

            public var success: Status200? {
                switch self {
                case .status200(let response): return response
                default: return nil
                }
            }

            public var response: Any {
                switch self {
                case .status200(let response): return response
                case .status400(let response): return response
                case .status404(let response): return response
                case .status500(let response): return response
                case .defaultResponse(_, let response): return response
                }
            }

            public var statusCode: Int {
                switch self {
                case .status200: return 200
                case .status400: return 400
                case .status404: return 404
                case .status500: return 500
                case .defaultResponse(let statusCode, _): return statusCode
                }
            }

            public var successful: Bool {
                switch self {
                case .status200: return true
                case .status400: return false
                case .status404: return false
                case .status500: return false
                case .defaultResponse: return false
                }
            }

            public init(statusCode: Int, data: Data, decoder: ResponseDecoder) throws {
                switch statusCode {
                case 200: self = try .status200(decoder.decode(Status200.self, from: data))
                case 400: self = try .status400(decoder.decode(Status400.self, from: data))
                case 404: self = try .status404(decoder.decode(Status404.self, from: data))
                case 500: self = try .status500(decoder.decode(Status500.self, from: data))
                default: self = try .defaultResponse(statusCode: statusCode, decoder.decode(DefaultResponse.self, from: data))
                }
            }

            public var description: String {
                return "\(statusCode) \(successful ? "success" : "failure")"
            }

            public var debugDescription: String {
                var string = description
                let responseString = "\(response)"
                if responseString != "()" {
                    string += "\n\(responseString)"
                }
                return string
            }
        }
    }
}
