//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

extension Rocket.Authorization {

    /** Request one or more `Account` level authorization tokens each with a chosen scope.
Tokens are used to access restricted service endpoints. These restricted endpoints
will require a specific token type (e.g Account) with a specific scope (e.g. Catalog)
before access is granted.
For convenience, where a Profile level token with the same scope exists it will also be returned.
This removes the need to prompt a user for a password on login followed directly with a
pin prompt for a profile token of the same scope.
Where an Account level pin is supported, some tokens may be returned from this endpoint
by providing this pin instead of a password. For example the `Playback` scoped Account
token is one such type.
Any token which is returnable with an Account pin will also be returnable with the
Account password. On the inverse, not all scoped tokens that are returnable via password
will be returnable via the pin. For example when you log in you receive an Account Catalog
token. This is not obtainable from an Account pin, only password.
If both a pin and password are supplied only the password will be used.
If neither a pin or password are supplied an http 400 error will be returned.
 */
    public enum GetAccountToken {

        public static let service = APIService<Response>(id: "getAccountToken", tag: "authorization", method: "POST", path: "/authorization", hasBody: true, securityRequirements: [])

        /** The scope(s) of the tokens required.
        For each scope listed an Account and Profile token of that scope will be returned
         */
        public enum Scopes: String, Codable, Equatable, CaseIterable {
            case catalog = "Catalog"
            case commerce = "Commerce"
            case settings = "Settings"
            case playback = "Playback"
        }

        /** If you specify a cookie type then a content filter cookie will be returned
        along with the token(s). This is only really intended for web based clients which
        need to pass the cookies to a server to render a page based on the users
        content filters, e.g subscription code.
        If type `Session` the cookie will be session based.
        If type `Persistent` the cookie will have a medium term lifespan.
        If undefined no cookies will be set.
         */
        public enum CookieType: String, Codable, Equatable, CaseIterable {
            case session = "Session"
            case persistent = "Persistent"
        }

        public final class Request: APIRequest<Response> {

            /** Request one or more `Account` level authorization tokens each with a chosen scope.
            Tokens are used to access restricted service endpoints. These restricted endpoints
            will require a specific token type (e.g Account) with a specific scope (e.g. Catalog)
            before access is granted.
            For convenience, where a Profile level token with the same scope exists it will also be returned.
            This removes the need to prompt a user for a password on login followed directly with a
            pin prompt for a profile token of the same scope.
            Where an Account level pin is supported, some tokens may be returned from this endpoint
            by providing this pin instead of a password. For example the `Playback` scoped Account
            token is one such type.
            Any token which is returnable with an Account pin will also be returnable with the
            Account password. On the inverse, not all scoped tokens that are returnable via password
            will be returnable via the pin. For example when you log in you receive an Account Catalog
            token. This is not obtainable from an Account pin, only password.
            If both a pin and password are supplied only the password will be used.
            If neither a pin or password are supplied an http 400 error will be returned.
             */
            public class Body: APIModel {

                /** The scope(s) of the tokens required.
                For each scope listed an Account and Profile token of that scope will be returned
                 */
                public enum Scopes: String, Codable, Equatable, CaseIterable {
                    case catalog = "Catalog"
                    case commerce = "Commerce"
                    case settings = "Settings"
                    case playback = "Playback"
                }

                /** If you specify a cookie type then a content filter cookie will be returned
                along with the token(s). This is only really intended for web based clients which
                need to pass the cookies to a server to render a page based on the users
                content filters, e.g subscription code.
                If type `Session` the cookie will be session based.
                If type `Persistent` the cookie will have a medium term lifespan.
                If undefined no cookies will be set.
                 */
                public enum CookieType: String, Codable, Equatable, CaseIterable {
                    case session = "Session"
                    case persistent = "Persistent"
                }

                /** The email associated with the account. */
                public var email: String

                /** The scope(s) of the tokens required.
            For each scope listed an Account and Profile token of that scope will be returned
             */
                public var scopes: [Scopes]

                /** If you specify a cookie type then a content filter cookie will be returned
            along with the token(s). This is only really intended for web based clients which
            need to pass the cookies to a server to render a page based on the users
            content filters, e.g subscription code.
            If type `Session` the cookie will be session based.
            If type `Persistent` the cookie will have a medium term lifespan.
            If undefined no cookies will be set.
             */
                public var cookieType: CookieType?

                /** The password associated with the account.
            Either a pin or password should be supplied. If both are supplied the password will take precedence.
             */
                public var password: String?

                /** The pin associated with the account.
            Either a pin or password should be supplied. If both are supplied the password will take precedence.
             */
                public var pin: String?

                public init(email: String, scopes: [Scopes], cookieType: CookieType? = nil, password: String? = nil, pin: String? = nil) {
                    self.email = email
                    self.scopes = scopes
                    self.cookieType = cookieType
                    self.password = password
                    self.pin = pin
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    email = try container.decode("email")
                    scopes = try container.decodeArray("scopes")
                    cookieType = try container.decodeIfPresent("cookieType")
                    password = try container.decodeIfPresent("password")
                    pin = try container.decodeIfPresent("pin")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encode(email, forKey: "email")
                    try container.encode(scopes, forKey: "scopes")
                    try container.encodeIfPresent(cookieType, forKey: "cookieType")
                    try container.encodeIfPresent(password, forKey: "password")
                    try container.encodeIfPresent(pin, forKey: "pin")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Body else { return false }
                  guard self.email == object.email else { return false }
                  guard self.scopes == object.scopes else { return false }
                  guard self.cookieType == object.cookieType else { return false }
                  guard self.password == object.password else { return false }
                  guard self.pin == object.pin else { return false }
                  return true
                }

                public static func == (lhs: Body, rhs: Body) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            public var body: Body

            public init(body: Body, encoder: RequestEncoder? = nil) {
                self.body = body
                super.init(service: GetAccountToken.service) { defaultEncoder in
                    return try (encoder ?? defaultEncoder).encode(body)
                }
            }
        }

        public enum Response: APIResponseValue, CustomStringConvertible, CustomDebugStringConvertible {

            /** Request one or more `Account` level authorization tokens each with a chosen scope.
            Tokens are used to access restricted service endpoints. These restricted endpoints
            will require a specific token type (e.g Account) with a specific scope (e.g. Catalog)
            before access is granted.
            For convenience, where a Profile level token with the same scope exists it will also be returned.
            This removes the need to prompt a user for a password on login followed directly with a
            pin prompt for a profile token of the same scope.
            Where an Account level pin is supported, some tokens may be returned from this endpoint
            by providing this pin instead of a password. For example the `Playback` scoped Account
            token is one such type.
            Any token which is returnable with an Account pin will also be returnable with the
            Account password. On the inverse, not all scoped tokens that are returnable via password
            will be returnable via the pin. For example when you log in you receive an Account Catalog
            token. This is not obtainable from an Account pin, only password.
            If both a pin and password are supplied only the password will be used.
            If neither a pin or password are supplied an http 400 error will be returned.
             */
            public class Status400: APIModel {

                /** A description of the error. */
                public var message: String

                /** An optional code classifying the error. Should be taken in the context of the http status code. */
                public var code: Int?

                public init(message: String, code: Int? = nil) {
                    self.message = message
                    self.code = code
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    message = try container.decode("message")
                    code = try container.decodeIfPresent("code")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encode(message, forKey: "message")
                    try container.encodeIfPresent(code, forKey: "code")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status400 else { return false }
                  guard self.message == object.message else { return false }
                  guard self.code == object.code else { return false }
                  return true
                }

                public static func == (lhs: Status400, rhs: Status400) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            /** Request one or more `Account` level authorization tokens each with a chosen scope.
            Tokens are used to access restricted service endpoints. These restricted endpoints
            will require a specific token type (e.g Account) with a specific scope (e.g. Catalog)
            before access is granted.
            For convenience, where a Profile level token with the same scope exists it will also be returned.
            This removes the need to prompt a user for a password on login followed directly with a
            pin prompt for a profile token of the same scope.
            Where an Account level pin is supported, some tokens may be returned from this endpoint
            by providing this pin instead of a password. For example the `Playback` scoped Account
            token is one such type.
            Any token which is returnable with an Account pin will also be returnable with the
            Account password. On the inverse, not all scoped tokens that are returnable via password
            will be returnable via the pin. For example when you log in you receive an Account Catalog
            token. This is not obtainable from an Account pin, only password.
            If both a pin and password are supplied only the password will be used.
            If neither a pin or password are supplied an http 400 error will be returned.
             */
            public class Status401: APIModel {

                /** A description of the error. */
                public var message: String

                /** An optional code classifying the error. Should be taken in the context of the http status code. */
                public var code: Int?

                public init(message: String, code: Int? = nil) {
                    self.message = message
                    self.code = code
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    message = try container.decode("message")
                    code = try container.decodeIfPresent("code")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encode(message, forKey: "message")
                    try container.encodeIfPresent(code, forKey: "code")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status401 else { return false }
                  guard self.message == object.message else { return false }
                  guard self.code == object.code else { return false }
                  return true
                }

                public static func == (lhs: Status401, rhs: Status401) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            /** Request one or more `Account` level authorization tokens each with a chosen scope.
            Tokens are used to access restricted service endpoints. These restricted endpoints
            will require a specific token type (e.g Account) with a specific scope (e.g. Catalog)
            before access is granted.
            For convenience, where a Profile level token with the same scope exists it will also be returned.
            This removes the need to prompt a user for a password on login followed directly with a
            pin prompt for a profile token of the same scope.
            Where an Account level pin is supported, some tokens may be returned from this endpoint
            by providing this pin instead of a password. For example the `Playback` scoped Account
            token is one such type.
            Any token which is returnable with an Account pin will also be returnable with the
            Account password. On the inverse, not all scoped tokens that are returnable via password
            will be returnable via the pin. For example when you log in you receive an Account Catalog
            token. This is not obtainable from an Account pin, only password.
            If both a pin and password are supplied only the password will be used.
            If neither a pin or password are supplied an http 400 error will be returned.
             */
            public class Status403: APIModel {

                /** A description of the error. */
                public var message: String

                /** An optional code classifying the error. Should be taken in the context of the http status code. */
                public var code: Int?

                public init(message: String, code: Int? = nil) {
                    self.message = message
                    self.code = code
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    message = try container.decode("message")
                    code = try container.decodeIfPresent("code")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encode(message, forKey: "message")
                    try container.encodeIfPresent(code, forKey: "code")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status403 else { return false }
                  guard self.message == object.message else { return false }
                  guard self.code == object.code else { return false }
                  return true
                }

                public static func == (lhs: Status403, rhs: Status403) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            /** Request one or more `Account` level authorization tokens each with a chosen scope.
            Tokens are used to access restricted service endpoints. These restricted endpoints
            will require a specific token type (e.g Account) with a specific scope (e.g. Catalog)
            before access is granted.
            For convenience, where a Profile level token with the same scope exists it will also be returned.
            This removes the need to prompt a user for a password on login followed directly with a
            pin prompt for a profile token of the same scope.
            Where an Account level pin is supported, some tokens may be returned from this endpoint
            by providing this pin instead of a password. For example the `Playback` scoped Account
            token is one such type.
            Any token which is returnable with an Account pin will also be returnable with the
            Account password. On the inverse, not all scoped tokens that are returnable via password
            will be returnable via the pin. For example when you log in you receive an Account Catalog
            token. This is not obtainable from an Account pin, only password.
            If both a pin and password are supplied only the password will be used.
            If neither a pin or password are supplied an http 400 error will be returned.
             */
            public class Status404: APIModel {

                /** A description of the error. */
                public var message: String

                /** An optional code classifying the error. Should be taken in the context of the http status code. */
                public var code: Int?

                public init(message: String, code: Int? = nil) {
                    self.message = message
                    self.code = code
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    message = try container.decode("message")
                    code = try container.decodeIfPresent("code")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encode(message, forKey: "message")
                    try container.encodeIfPresent(code, forKey: "code")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status404 else { return false }
                  guard self.message == object.message else { return false }
                  guard self.code == object.code else { return false }
                  return true
                }

                public static func == (lhs: Status404, rhs: Status404) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            /** Request one or more `Account` level authorization tokens each with a chosen scope.
            Tokens are used to access restricted service endpoints. These restricted endpoints
            will require a specific token type (e.g Account) with a specific scope (e.g. Catalog)
            before access is granted.
            For convenience, where a Profile level token with the same scope exists it will also be returned.
            This removes the need to prompt a user for a password on login followed directly with a
            pin prompt for a profile token of the same scope.
            Where an Account level pin is supported, some tokens may be returned from this endpoint
            by providing this pin instead of a password. For example the `Playback` scoped Account
            token is one such type.
            Any token which is returnable with an Account pin will also be returnable with the
            Account password. On the inverse, not all scoped tokens that are returnable via password
            will be returnable via the pin. For example when you log in you receive an Account Catalog
            token. This is not obtainable from an Account pin, only password.
            If both a pin and password are supplied only the password will be used.
            If neither a pin or password are supplied an http 400 error will be returned.
             */
            public class Status500: APIModel {

                /** A description of the error. */
                public var message: String

                /** An optional code classifying the error. Should be taken in the context of the http status code. */
                public var code: Int?

                public init(message: String, code: Int? = nil) {
                    self.message = message
                    self.code = code
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    message = try container.decode("message")
                    code = try container.decodeIfPresent("code")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encode(message, forKey: "message")
                    try container.encodeIfPresent(code, forKey: "code")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status500 else { return false }
                  guard self.message == object.message else { return false }
                  guard self.code == object.code else { return false }
                  return true
                }

                public static func == (lhs: Status500, rhs: Status500) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            /** Request one or more `Account` level authorization tokens each with a chosen scope.
            Tokens are used to access restricted service endpoints. These restricted endpoints
            will require a specific token type (e.g Account) with a specific scope (e.g. Catalog)
            before access is granted.
            For convenience, where a Profile level token with the same scope exists it will also be returned.
            This removes the need to prompt a user for a password on login followed directly with a
            pin prompt for a profile token of the same scope.
            Where an Account level pin is supported, some tokens may be returned from this endpoint
            by providing this pin instead of a password. For example the `Playback` scoped Account
            token is one such type.
            Any token which is returnable with an Account pin will also be returnable with the
            Account password. On the inverse, not all scoped tokens that are returnable via password
            will be returnable via the pin. For example when you log in you receive an Account Catalog
            token. This is not obtainable from an Account pin, only password.
            If both a pin and password are supplied only the password will be used.
            If neither a pin or password are supplied an http 400 error will be returned.
             */
            public class DefaultResponse: APIModel {

                /** A description of the error. */
                public var message: String

                /** An optional code classifying the error. Should be taken in the context of the http status code. */
                public var code: Int?

                public init(message: String, code: Int? = nil) {
                    self.message = message
                    self.code = code
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    message = try container.decode("message")
                    code = try container.decodeIfPresent("code")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encode(message, forKey: "message")
                    try container.encodeIfPresent(code, forKey: "code")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? DefaultResponse else { return false }
                  guard self.message == object.message else { return false }
                  guard self.code == object.code else { return false }
                  return true
                }

                public static func == (lhs: DefaultResponse, rhs: DefaultResponse) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }
            public typealias SuccessType = [AccessToken]

            /** OK */
            case status200([AccessToken])

            /** Bad request. */
            case status400(Status400)

            /** Invalid access token. */
            case status401(Status401)

            /** Forbidden. */
            case status403(Status403)

            /** Not found. */
            case status404(Status404)

            /** Internal server error. */
            case status500(Status500)

            /** Service error. */
            case defaultResponse(statusCode: Int, DefaultResponse)

            public var success: [AccessToken]? {
                switch self {
                case .status200(let response): return response
                default: return nil
                }
            }

            public var response: Any {
                switch self {
                case .status200(let response): return response
                case .status400(let response): return response
                case .status401(let response): return response
                case .status403(let response): return response
                case .status404(let response): return response
                case .status500(let response): return response
                case .defaultResponse(_, let response): return response
                }
            }

            public var statusCode: Int {
                switch self {
                case .status200: return 200
                case .status400: return 400
                case .status401: return 401
                case .status403: return 403
                case .status404: return 404
                case .status500: return 500
                case .defaultResponse(let statusCode, _): return statusCode
                }
            }

            public var successful: Bool {
                switch self {
                case .status200: return true
                case .status400: return false
                case .status401: return false
                case .status403: return false
                case .status404: return false
                case .status500: return false
                case .defaultResponse: return false
                }
            }

            public init(statusCode: Int, data: Data, decoder: ResponseDecoder) throws {
                switch statusCode {
                case 200: self = try .status200(decoder.decode([AccessToken].self, from: data))
                case 400: self = try .status400(decoder.decode(Status400.self, from: data))
                case 401: self = try .status401(decoder.decode(Status401.self, from: data))
                case 403: self = try .status403(decoder.decode(Status403.self, from: data))
                case 404: self = try .status404(decoder.decode(Status404.self, from: data))
                case 500: self = try .status500(decoder.decode(Status500.self, from: data))
                default: self = try .defaultResponse(statusCode: statusCode, decoder.decode(DefaultResponse.self, from: data))
                }
            }

            public var description: String {
                return "\(statusCode) \(successful ? "success" : "failure")"
            }

            public var debugDescription: String {
                var string = description
                let responseString = "\(response)"
                if responseString != "()" {
                    string += "\n\(responseString)"
                }
                return string
            }
        }
    }
}
