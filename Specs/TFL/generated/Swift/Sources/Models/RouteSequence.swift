//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class RouteSequence: Codable, Equatable {

    public var direction: String?

    public var isOutboundOnly: Bool?

    public var lineId: String?

    public var lineName: String?

    public var lineStrings: [String]?

    public var mode: String?

    public var orderedLineRoutes: [OrderedRoute]?

    public var stations: [MatchedStop]?

    public var stopPointSequences: [StopPointSequence]?

    public init(direction: String? = nil, isOutboundOnly: Bool? = nil, lineId: String? = nil, lineName: String? = nil, lineStrings: [String]? = nil, mode: String? = nil, orderedLineRoutes: [OrderedRoute]? = nil, stations: [MatchedStop]? = nil, stopPointSequences: [StopPointSequence]? = nil) {
        self.direction = direction
        self.isOutboundOnly = isOutboundOnly
        self.lineId = lineId
        self.lineName = lineName
        self.lineStrings = lineStrings
        self.mode = mode
        self.orderedLineRoutes = orderedLineRoutes
        self.stations = stations
        self.stopPointSequences = stopPointSequences
    }

    private enum CodingKeys: String, CodingKey {
        case direction
        case isOutboundOnly
        case lineId
        case lineName
        case lineStrings
        case mode
        case orderedLineRoutes
        case stations
        case stopPointSequences
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        direction = try container.decodeIfPresent(.direction)
        isOutboundOnly = try container.decodeIfPresent(.isOutboundOnly)
        lineId = try container.decodeIfPresent(.lineId)
        lineName = try container.decodeIfPresent(.lineName)
        lineStrings = try container.decodeIfPresent(.lineStrings)
        mode = try container.decodeIfPresent(.mode)
        orderedLineRoutes = try container.decodeIfPresent(.orderedLineRoutes)
        stations = try container.decodeIfPresent(.stations)
        stopPointSequences = try container.decodeIfPresent(.stopPointSequences)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(direction, forKey: .direction)
        try container.encode(isOutboundOnly, forKey: .isOutboundOnly)
        try container.encode(lineId, forKey: .lineId)
        try container.encode(lineName, forKey: .lineName)
        try container.encode(lineStrings, forKey: .lineStrings)
        try container.encode(mode, forKey: .mode)
        try container.encode(orderedLineRoutes, forKey: .orderedLineRoutes)
        try container.encode(stations, forKey: .stations)
        try container.encode(stopPointSequences, forKey: .stopPointSequences)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? RouteSequence else { return false }
      guard self.direction == object.direction else { return false }
      guard self.isOutboundOnly == object.isOutboundOnly else { return false }
      guard self.lineId == object.lineId else { return false }
      guard self.lineName == object.lineName else { return false }
      guard self.lineStrings == object.lineStrings else { return false }
      guard self.mode == object.mode else { return false }
      guard self.orderedLineRoutes == object.orderedLineRoutes else { return false }
      guard self.stations == object.stations else { return false }
      guard self.stopPointSequences == object.stopPointSequences else { return false }
      return true
    }

    public static func == (lhs: RouteSequence, rhs: RouteSequence) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
