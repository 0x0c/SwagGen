//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class MatchedStop: Codable, Equatable {

    public var accessibilitySummary: String?

    public var direction: String?

    public var hasDisruption: Bool?

    public var icsId: String?

    public var id: String?

    public var lat: Double?

    public var lines: [Identifier]?

    public var lon: Double?

    public var modes: [String]?

    public var name: String?

    public var parentId: String?

    public var routeId: Int?

    public var stationId: String?

    public var status: Bool?

    public var stopLetter: String?

    public var stopType: String?

    public var topMostParentId: String?

    public var towards: String?

    public var url: String?

    public var zone: String?

    public init(accessibilitySummary: String? = nil, direction: String? = nil, hasDisruption: Bool? = nil, icsId: String? = nil, id: String? = nil, lat: Double? = nil, lines: [Identifier]? = nil, lon: Double? = nil, modes: [String]? = nil, name: String? = nil, parentId: String? = nil, routeId: Int? = nil, stationId: String? = nil, status: Bool? = nil, stopLetter: String? = nil, stopType: String? = nil, topMostParentId: String? = nil, towards: String? = nil, url: String? = nil, zone: String? = nil) {
        self.accessibilitySummary = accessibilitySummary
        self.direction = direction
        self.hasDisruption = hasDisruption
        self.icsId = icsId
        self.id = id
        self.lat = lat
        self.lines = lines
        self.lon = lon
        self.modes = modes
        self.name = name
        self.parentId = parentId
        self.routeId = routeId
        self.stationId = stationId
        self.status = status
        self.stopLetter = stopLetter
        self.stopType = stopType
        self.topMostParentId = topMostParentId
        self.towards = towards
        self.url = url
        self.zone = zone
    }

    private enum CodingKeys: String, CodingKey {
        case accessibilitySummary
        case direction
        case hasDisruption
        case icsId
        case id
        case lat
        case lines
        case lon
        case modes
        case name
        case parentId
        case routeId
        case stationId
        case status
        case stopLetter
        case stopType
        case topMostParentId
        case towards
        case url
        case zone
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        accessibilitySummary = try container.decodeIfPresent(.accessibilitySummary)
        direction = try container.decodeIfPresent(.direction)
        hasDisruption = try container.decodeIfPresent(.hasDisruption)
        icsId = try container.decodeIfPresent(.icsId)
        id = try container.decodeIfPresent(.id)
        lat = try container.decodeIfPresent(.lat)
        lines = try container.decodeArrayIfPresent(.lines)
        lon = try container.decodeIfPresent(.lon)
        modes = try container.decodeArrayIfPresent(.modes)
        name = try container.decodeIfPresent(.name)
        parentId = try container.decodeIfPresent(.parentId)
        routeId = try container.decodeIfPresent(.routeId)
        stationId = try container.decodeIfPresent(.stationId)
        status = try container.decodeIfPresent(.status)
        stopLetter = try container.decodeIfPresent(.stopLetter)
        stopType = try container.decodeIfPresent(.stopType)
        topMostParentId = try container.decodeIfPresent(.topMostParentId)
        towards = try container.decodeIfPresent(.towards)
        url = try container.decodeIfPresent(.url)
        zone = try container.decodeIfPresent(.zone)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(accessibilitySummary, forKey: .accessibilitySummary)
        try container.encode(direction, forKey: .direction)
        try container.encode(hasDisruption, forKey: .hasDisruption)
        try container.encode(icsId, forKey: .icsId)
        try container.encode(id, forKey: .id)
        try container.encode(lat, forKey: .lat)
        try container.encode(lines, forKey: .lines)
        try container.encode(lon, forKey: .lon)
        try container.encode(modes, forKey: .modes)
        try container.encode(name, forKey: .name)
        try container.encode(parentId, forKey: .parentId)
        try container.encode(routeId, forKey: .routeId)
        try container.encode(stationId, forKey: .stationId)
        try container.encode(status, forKey: .status)
        try container.encode(stopLetter, forKey: .stopLetter)
        try container.encode(stopType, forKey: .stopType)
        try container.encode(topMostParentId, forKey: .topMostParentId)
        try container.encode(towards, forKey: .towards)
        try container.encode(url, forKey: .url)
        try container.encode(zone, forKey: .zone)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? MatchedStop else { return false }
      guard self.accessibilitySummary == object.accessibilitySummary else { return false }
      guard self.direction == object.direction else { return false }
      guard self.hasDisruption == object.hasDisruption else { return false }
      guard self.icsId == object.icsId else { return false }
      guard self.id == object.id else { return false }
      guard self.lat == object.lat else { return false }
      guard self.lines == object.lines else { return false }
      guard self.lon == object.lon else { return false }
      guard self.modes == object.modes else { return false }
      guard self.name == object.name else { return false }
      guard self.parentId == object.parentId else { return false }
      guard self.routeId == object.routeId else { return false }
      guard self.stationId == object.stationId else { return false }
      guard self.status == object.status else { return false }
      guard self.stopLetter == object.stopLetter else { return false }
      guard self.stopType == object.stopType else { return false }
      guard self.topMostParentId == object.topMostParentId else { return false }
      guard self.towards == object.towards else { return false }
      guard self.url == object.url else { return false }
      guard self.zone == object.zone else { return false }
      return true
    }

    public static func == (lhs: MatchedStop, rhs: MatchedStop) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
