//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

extension TFL.Line {

    /** Gets all valid routes for given line id, including the sequence of stops on each route. */
    public enum LineRouteSequence {

        public static let service = APIService<Response>(id: "Line_RouteSequence", tag: "Line", method: "GET", path: "/Line/{id}/Route/Sequence/{direction}", hasBody: false, securityRequirements: [])

        /** The direction of travel. Can be inbound or outbound. */
        public enum Direction: String, Codable, Equatable, CaseIterable {
            case inbound = "inbound"
            case outbound = "outbound"
            case all = "all"
        }

        /** A comma seperated list of service types to filter on. Supported values: Regular, Night. Defaulted to 'Regular' if not specified */
        public enum ServiceTypes: String, Codable, Equatable, CaseIterable {
            case regular = "Regular"
            case night = "Night"
        }

        public final class Request: APIRequest<Response> {

            public struct Options {

                /** A single line id e.g. victoria */
                public var id: String

                /** The direction of travel. Can be inbound or outbound. */
                public var direction: Direction

                /** A comma seperated list of service types to filter on. Supported values: Regular, Night. Defaulted to 'Regular' if not specified */
                public var serviceTypes: [ServiceTypes]?

                /** That excludes crowding from line disruptions. Can be true or false. */
                public var excludeCrowding: Bool?

                public init(id: String, direction: Direction, serviceTypes: [ServiceTypes]? = nil, excludeCrowding: Bool? = nil) {
                    self.id = id
                    self.direction = direction
                    self.serviceTypes = serviceTypes
                    self.excludeCrowding = excludeCrowding
                }
            }

            public var options: Options

            public init(options: Options) {
                self.options = options
                super.init(service: LineRouteSequence.service)
            }

            /// convenience initialiser so an Option doesn't have to be created
            public convenience init(id: String, direction: Direction, serviceTypes: [ServiceTypes]? = nil, excludeCrowding: Bool? = nil) {
                let options = Options(id: id, direction: direction, serviceTypes: serviceTypes, excludeCrowding: excludeCrowding)
                self.init(options: options)
            }

            public override var path: String {
                return super.path.replacingOccurrences(of: "{" + "id" + "}", with: "\(self.options.id)").replacingOccurrences(of: "{" + "direction" + "}", with: "\(self.options.direction.encode())")
            }

            public override var queryParameters: [String: Any] {
                var params: [String: Any] = [:]
                if let serviceTypes = options.serviceTypes?.encode().map({ String(describing: $0) }).joined(separator: ",") {
                  params["serviceTypes"] = serviceTypes
                }
                if let excludeCrowding = options.excludeCrowding {
                  params["excludeCrowding"] = excludeCrowding
                }
                return params
            }
        }

        public enum Response: APIResponseValue, CustomStringConvertible, CustomDebugStringConvertible {

            public class Status200: APIModel {

                public var direction: String?

                public var isOutboundOnly: Bool?

                public var lineId: String?

                public var lineName: String?

                public var lineStrings: [String]?

                public var mode: String?

                public var orderedLineRoutes: [OrderedRoute]?

                public var stations: [MatchedStop]?

                public var stopPointSequences: [StopPointSequence]?

                public init(direction: String? = nil, isOutboundOnly: Bool? = nil, lineId: String? = nil, lineName: String? = nil, lineStrings: [String]? = nil, mode: String? = nil, orderedLineRoutes: [OrderedRoute]? = nil, stations: [MatchedStop]? = nil, stopPointSequences: [StopPointSequence]? = nil) {
                    self.direction = direction
                    self.isOutboundOnly = isOutboundOnly
                    self.lineId = lineId
                    self.lineName = lineName
                    self.lineStrings = lineStrings
                    self.mode = mode
                    self.orderedLineRoutes = orderedLineRoutes
                    self.stations = stations
                    self.stopPointSequences = stopPointSequences
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    direction = try container.decodeIfPresent("direction")
                    isOutboundOnly = try container.decodeIfPresent("isOutboundOnly")
                    lineId = try container.decodeIfPresent("lineId")
                    lineName = try container.decodeIfPresent("lineName")
                    lineStrings = try container.decodeArrayIfPresent("lineStrings")
                    mode = try container.decodeIfPresent("mode")
                    orderedLineRoutes = try container.decodeArrayIfPresent("orderedLineRoutes")
                    stations = try container.decodeArrayIfPresent("stations")
                    stopPointSequences = try container.decodeArrayIfPresent("stopPointSequences")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encodeIfPresent(direction, forKey: "direction")
                    try container.encodeIfPresent(isOutboundOnly, forKey: "isOutboundOnly")
                    try container.encodeIfPresent(lineId, forKey: "lineId")
                    try container.encodeIfPresent(lineName, forKey: "lineName")
                    try container.encodeIfPresent(lineStrings, forKey: "lineStrings")
                    try container.encodeIfPresent(mode, forKey: "mode")
                    try container.encodeIfPresent(orderedLineRoutes, forKey: "orderedLineRoutes")
                    try container.encodeIfPresent(stations, forKey: "stations")
                    try container.encodeIfPresent(stopPointSequences, forKey: "stopPointSequences")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status200 else { return false }
                  guard self.direction == object.direction else { return false }
                  guard self.isOutboundOnly == object.isOutboundOnly else { return false }
                  guard self.lineId == object.lineId else { return false }
                  guard self.lineName == object.lineName else { return false }
                  guard self.lineStrings == object.lineStrings else { return false }
                  guard self.mode == object.mode else { return false }
                  guard self.orderedLineRoutes == object.orderedLineRoutes else { return false }
                  guard self.stations == object.stations else { return false }
                  guard self.stopPointSequences == object.stopPointSequences else { return false }
                  return true
                }

                public static func == (lhs: Status200, rhs: Status200) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }
            public typealias SuccessType = Status200

            /** OK */
            case status200(Status200)

            public var success: Status200? {
                switch self {
                case .status200(let response): return response
                }
            }

            public var response: Any {
                switch self {
                case .status200(let response): return response
                }
            }

            public var statusCode: Int {
                switch self {
                case .status200: return 200
                }
            }

            public var successful: Bool {
                switch self {
                case .status200: return true
                }
            }

            public init(statusCode: Int, data: Data, decoder: ResponseDecoder) throws {
                switch statusCode {
                case 200: self = try .status200(decoder.decode(Status200.self, from: data))
                default: throw APIClientError.unexpectedStatusCode(statusCode: statusCode, data: data)
                }
            }

            public var description: String {
                return "\(statusCode) \(successful ? "success" : "failure")"
            }

            public var debugDescription: String {
                var string = description
                let responseString = "\(response)"
                if responseString != "()" {
                    string += "\n\(responseString)"
                }
                return string
            }
        }
    }
}
